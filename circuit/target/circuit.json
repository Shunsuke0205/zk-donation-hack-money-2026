{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"12721324340487468277","abi":{"parameters":[{"name":"x","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/6VRuwrCMBTNo0rdRNq9o26KPyCI4CSOLiJiM2SwSCgFx36C+AN+hejndHN0cVfxBm5DhEQPhJOc3MfJDSUfBMDbtcwYOtPX4sBvjAyNgobjTTDghDiB4th+OlPV4NS7zCfnslwsu8PbdH/dHcbV43iH4MStbs0b+8cc8zTIUAGfvFpTYh+u1trAqVRik8tCrGRWCJW3QA+BY5THifu7dX70Wz5pWrQY7XVd3cc2M1dw4IblTtcNjNjQYOrfn37zYfu3DnCEND2PJwi44bmVAwAA","debug_symbols":"dU/bCoMwDP2XPPfBbnMDf2UMqTVKIbQltoMh/fdFUXQPe8nt5JzkzNBjl8fW+SFM0Dxn6NgRubGlYE1ywct0Lgr2tk2MKCM44cKKhtEnaHwmUvA2lNelKRq/5mRY0EoB+l6yCA6OcKmKOtjVf2qt77eNXevHIVDrUl7SGev452e4QKMVXCWWRZad6Qg3N0P29mQufeKO7PYjB4t9ZlxEV0zOfAE=","file_map":{"51":{"source":"// All comments must be in English.\n\nuse dep::poseidon::poseidon;\n\nglobal MERKLE_DEPTH: u32 = 3; // 3 for demo\n\nstruct Note {\n    amount: u64,  // Purpose Bound Money amount\n    pbm_token_id: u32,\n    owner: Field,   // Hash(Pubkey) of Sender (for old) or Receiver (for new)\n    donor: Field,   // Hash(Pubkey) of the Original Donor (Fixed)\n    salt: Field,\n}\n\nfn note_hash(note: Note) -> Field {\n    let inputs = [\n        note.amount as Field,\n        note.pbm_token_id as Field,\n        note.owner,\n        note.donor,\n        note.salt,\n    ];\n    poseidon::bn254::hash_5(inputs)\n}\n\nfn compute_merkle_proof(\n    leaf: Field,\n    index: u32,\n    path: [Field; MERKLE_DEPTH],\n) -> Field {\n    let mut current_hash = leaf;\n    let mut current_index = index;\n\n    for i in 0..MERKLE_DEPTH {\n        let sibling_hash = path[i];\n        let is_right = current_index % 2;\n        if is_right == 0 {\n            current_hash = poseidon::bn254::hash_2([current_hash, sibling_hash]);\n        } else {\n            current_hash = poseidon::bn254::hash_2([sibling_hash, current_hash]);\n        }\n        current_index = current_index / 2;\n    }\n\n    current_hash\n}\n\nfn verify_old_note(\n    old_note: Note,\n    pbm_token_id: u32,\n    donor_public_point: std::embedded_curve_ops::EmbeddedCurvePoint,\n    owner_private_key: std::embedded_curve_ops::EmbeddedCurveScalar,\n    nullifier: Field,\n    merkle_root: Field,\n    merkle_index: u32,\n    merkle_path: [Field; MERKLE_DEPTH],\n    is_dummy: bool,\n) {\n    assert_eq(old_note.pbm_token_id, pbm_token_id, \"PBM Token ID does not match\");\n    {\n        let derived_donor_hash = poseidon::bn254::hash_2([\n            donor_public_point.x,\n            donor_public_point.y,\n        ]);\n        assert_eq(old_note.donor, derived_donor_hash, \"Donor public key mismatch for old note\");\n    }\n    {\n        let derived_owner_public_point = std::embedded_curve_ops::fixed_base_scalar_mul(owner_private_key);\n        let derived_owner_hash = poseidon::bn254::hash_2([\n            derived_owner_public_point.x,\n            derived_owner_public_point.y,\n        ]);\n        assert_eq(derived_owner_hash, old_note.owner, \"Owner private key mismatch for old note\");\n    }\n\n    let old_note_hash = note_hash(old_note);\n    let derived_nullifier = poseidon::bn254::hash_3([\n        old_note_hash,\n        owner_private_key.hi,\n        owner_private_key.lo,\n    ]);\n    assert_eq(derived_nullifier, nullifier, \"Nullifier does not match\");\n\n    let calculated_merkle_root = compute_merkle_proof(old_note_hash, merkle_index, merkle_path);\n    if is_dummy {\n        assert_eq(old_note.amount, 0, \"Dummy note amount must be zero\");\n    } else {\n        assert(old_note.amount > 0, \"Old note amount must be greater than zero\");\n        assert_eq(calculated_merkle_root, merkle_root, \"Merkle root does not match\");\n    }\n}\n\nfn verify_new_note(\n    new_note: Note,\n    new_note_hash: Field,\n    pbm_token_id: u32,\n    receiver_public_point: std::embedded_curve_ops::EmbeddedCurvePoint,\n    donor_public_point: std::embedded_curve_ops::EmbeddedCurvePoint,\n) {\n    assert_eq(note_hash(new_note), new_note_hash, \"New note hash does not match\");\n\n    assert_eq(new_note.pbm_token_id, pbm_token_id, \"PBM Token ID does not match for new note\");\n\n    let derived_receiver_hash = poseidon::bn254::hash_2([\n        receiver_public_point.x,\n        receiver_public_point.y,\n    ]);\n    assert_eq(new_note.owner, derived_receiver_hash, \"Receiver public key mismatch for new note\");\n\n    let derived_donor_hash = poseidon::bn254::hash_2([\n        donor_public_point.x,\n        donor_public_point.y,\n    ]);\n    assert_eq(new_note.donor, derived_donor_hash, \"Donor public key mismatch for new note\");\n}\n\nstruct Scalar256bits {\n    low: u128,\n    high: u128,\n}\n\nfn verify_encryption(\n    encryption_randomness: std::embedded_curve_ops::EmbeddedCurveScalar,\n    public_point: std::embedded_curve_ops::EmbeddedCurvePoint,\n    ephemeral_public_point: std::embedded_curve_ops::EmbeddedCurvePoint, // [TX output]\n    shared_secret_low: Field,\n    shared_secret_high: Field,\n    encrypted_key_low: Field,\n    encrypted_key_high: Field,\n) {\n    {\n        let derived_ephemeral_public_point = std::embedded_curve_ops::fixed_base_scalar_mul(encryption_randomness);\n        assert_eq(derived_ephemeral_public_point.x, ephemeral_public_point.x, \"Ephemeral public point X mismatch\");\n        assert_eq(derived_ephemeral_public_point.y, ephemeral_public_point.y, \"Ephemeral public point Y mismatch\");\n    }\n\n    let shared_point: std::embedded_curve_ops::EmbeddedCurvePoint = std::embedded_curve_ops::multi_scalar_mul([public_point], [encryption_randomness]);\n\n    let keystream_low = poseidon::bn254::hash_2([shared_point.x, 1]);\n    let keystream_high = poseidon::bn254::hash_2([shared_point.x, 2]);\n    let derived_encrypted_key_low = shared_secret_low + keystream_low;\n    let derived_encrypted_key_high = shared_secret_high + keystream_high;\n\n    assert_eq(derived_encrypted_key_low, encrypted_key_low, \"Encrypted key low mismatch\");\n    assert_eq(derived_encrypted_key_high, encrypted_key_high, \"Encrypted key high mismatch\");\n}\n\n\nfn main(x: u64, y: pub u64) {\n    assert(x != y);\n}\n\n#[test]\nfn test_main() {\n    main(1, 2);\n\n    // Uncomment to make test fail\n    // main(1, 1);\n}\n\n#[test]\nfn test_compute_merkle_proof() {\n    let leaf = 0x1234;\n    \n    let node_a = 0x5678;\n    let node_c = 0x9abc;\n    let node_e = 0xdef0;\n\n    let path = [node_a, node_c, node_e];\n    let index = 2; // 010 in binary\n\n    let level_1 = poseidon::bn254::hash_2([leaf, node_a]);\n    \n    let level_2 = poseidon::bn254::hash_2([node_c, level_1]);\n    \n    let expected_root = poseidon::bn254::hash_2([level_2, node_e]);\n\n    let calculated_root = compute_merkle_proof(leaf, index, path);\n    \n    assert(calculated_root == expected_root);\n}\n\n#[test]\nfn test_merkle_proof_different_index() {\n    let leaf = 0x111;\n    let sibling = 0x222;\n    let path = [sibling, 0x333, 0x444];\n    \n    let root_0 = compute_merkle_proof(leaf, 0, path);\n    \n    let root_1 = compute_merkle_proof(leaf, 1, path);\n    \n    assert(root_0 != root_1);\n}","path":"/home/Shunsuke/Documents/blockchain/zk-donation-hack-money-2026/circuit/src/main.nr"}},"expression_width":{"Bounded":{"width":4}}}